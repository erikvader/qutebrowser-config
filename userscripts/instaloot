#!/bin/python

import os, sys, re, math, atexit
import threading as T
from time import sleep
from collections import OrderedDict
from bs4 import BeautifulSoup
from instalooter.looters import PostLooter
from instalooter._utils import NameGenerator
from fcntl import lockf, LOCK_SH, LOCK_EX

writeLock = T.Lock()
statsLock = T.Lock()
stats = {"downPost": 0, "downTotal": 0, "failPost": 0, "postHad": 0}

runningFile = "/tmp/instaloot_running"

dest = os.path.join(os.environ["HOME"], "Pictures/instagram")

cacheFile = "/tmp/instaloot_cache"
cache = OrderedDict()
cacheLast = -1

setdir = ""
setdirFile = "/tmp/instaloot_setdir"

def loadCache():
   global cacheLast
   if not os.path.isfile(cacheFile):
      return
   with open(cacheFile, "r") as f:
      lockf(f, LOCK_SH)
      for l in f:
         cache[l.rstrip("\n")] = None
      cacheLast = len(cache)

def saveCache():
   new_items = len(cache) - cacheLast
   if new_items == 0:
      return
   with open(cacheFile, "a") as f:
      lockf(f, LOCK_EX)
      for i, l in enumerate(reversed(cache)):
         if i >= new_items:
            break
         f.write(l + "\n")

def saveSetdir():
   with open(setdirFile, "w") as f:
      lockf(f, LOCK_EX)
      f.write(setdir)

def loadSetdir():
   global setdir
   if setdir:
      return
   if not os.path.isfile(setdirFile):
      return
   with open(setdirFile, "r") as f:
      lockf(f, LOCK_SH)
      setdir = f.readline()

def downloadPost(post):
   templ="{username}.{date}.{id}"
   looter = PostLooter(post, get_videos=True, jobs=1, template=templ)
   try:
      # find and create target dir
      username = looter.info['owner']['username']
      if setdir:
         targetPath = os.path.join(dest, setdir)
      else:
         targetPath = os.path.join(dest, username)
      os.makedirs(targetPath, exist_ok=True)

      # generate all target filenames and check if they exist
      namegen = NameGenerator(templ)
      media = next(looter.medias())
      exists = True
      total = 1
      if "edge_sidecar_to_children" in media:
         edges = media["edge_sidecar_to_children"]["edges"]
         total = len(edges)
         for m in edges:
            mc = media.copy()
            mc["id"] = m["node"]["id"]
            name = namegen.file(mc)
            if not os.path.isfile(os.path.join(targetPath, name)):
               exists = False
               break
      else:
         name = namegen.file(media)
         if not os.path.isfile(os.path.join(targetPath, name)):
            exists = False

      # download
      if not exists:
         looter.download(destination=targetPath)

      # record what happened
      with statsLock:
         cache[post] = None
         if exists:
            stats["postHad"] += 1
         else:
            stats["downPost"] += 1
            stats["downTotal"] += total
   except Exception as e:
      with statsLock:
         stats["failPost"] += 1
      qute_eprint(str(e))

def qute_print(msg):
   with writeLock:
      with open(os.environ["QUTE_FIFO"], "w") as f:
         f.write("message-info \"" + msg + "\"\n")

def qute_eprint(msg):
   with writeLock:
      with open(os.environ["QUTE_FIFO"], "w") as f:
         f.write("message-error \"" + msg + "\"\n")

def display_stats(post=None):
   if post:
      if stats["postHad"] > 0:
         qute_print("{} was already downloaded".format(post))
      elif stats["downPost"] > 0:
         qute_print("{} was successfully downloaded! ({} files in total)".format(post, stats["downTotal"]))
      else:
         qute_print("Error or something? post={}".format(post))
   else:
      qute_print("Downloaded {} new posts ({} files), {} failed and {} were already downloaded".format(stats["downPost"], stats["downTotal"], stats["failPost"], stats["postHad"]))

def run_all():
   try:
      with open(runningFile, "x") as f:
         f.write(str(os.getpid()))
      atexit.register(lambda: os.remove(runningFile))
   except FileExistsError:
      qute_eprint("Another instance of this script is already running in all-mode")
      return

   with open(os.environ["QUTE_HTML"], "r") as fp:
      soup = BeautifulSoup(fp, "html5lib")

   links = map(lambda x: x.get("href"), soup.find_all("a"))

   loadCache()

   plinks = []
   alreadySeen = 0
   for l in links:
      if not re.match(r"/p/", l): # FIXME: expected a string sometimes?????
         continue
      post = re.split(r"/", l)[2]
      if post not in cache:
         plinks.append(post)
      else:
         alreadySeen += 1

   amountPlinks = len(plinks)

   if amountPlinks == 0:
      qute_print("No new links found :( ({} were cached)".format(alreadySeen))
      return

   qute_print("found {} valid links and {} cached links, starting download...".format(amountPlinks, alreadySeen))

   milestones = [0.25, 0.5, 0.75]
   while True:
      pro = 1 - (len(plinks) / amountPlinks)
      last = None
      while milestones and pro >= milestones[0]:
         last = milestones[0]
         del milestones[0]
      if last != None:
         qute_print("reached {}%".format(math.floor(last*100)))

      if T.active_count() < 8+1 and plinks:
         thr = T.Thread(target=downloadPost, args=(plinks.pop(),))
         thr.start()
      elif T.active_count() == 1:
         break
      else:
         sleep(0.5)

   saveCache()
   display_stats()

def run_current():
   url = os.environ["QUTE_URL"]
   mat = re.match(r"^(https://)?(www\.)?instagram\.com/p/(.+?)(/|$)", url)
   if not mat:
      qute_print("{} is an invalid link :(".format(url))
      return

   post = mat.group(3)
   loadCache()
   if post in cache:
      qute_print("{} was in the cache".format(post))
      return
   else:
      # qute_print("Downloading {}...".format(post))
      downloadPost(post)
      saveCache()
      display_stats(post)


def main():
   global setdir
   display_usage = False
   load_setdir = True

   if not "QUTE_HTML" in os.environ:
      print("is this really running in qutebrowser?")
      exit(1)

   args = {}
   argv = sys.argv[1:].copy()
   while argv:
      a = argv.pop(0)
      if a == "--current":
         args['current'] = True
      elif a == "--all":
         args['all'] = True
      elif a == "--setdir":
         setdir = argv.pop(0)
         saveSetdir()
         load_setdir = False
         args["setdir"] = True
      elif a == "--cleardir":
         setdir = ""
         saveSetdir()
         load_setdir = False
         args["setdir"] = True
      else:
         display_usage = True
         break

   if load_setdir:
      loadSetdir()

   if setdir and load_setdir:
      qute_print("FYI using setdir=\\\"{}\\\"".format(setdir))

   if args.get("current", False):
      run_current()
   elif args.get("all", False):
      run_all()
   elif args.get("setdir", False):
      qute_print("Updated setdir to \\\"{}\\\"".format(setdir))
   else:
      display_usage = True

   if display_usage:
      qute_print("usage: instaloot ((--setdir dir | --cleardir) | (--current | --all))")
      exit(1)

if __name__ == "__main__":
   main()
