#!/bin/python

import os, sys, re, math, atexit
import threading as T
from time import sleep
from bs4 import BeautifulSoup
from instalooter.looters import PostLooter
from instalooter._utils import NameGenerator
from fcntl import lockf, LOCK_SH, LOCK_EX # TODO: Ã¤ndra till flock
import pickle as P

writeLock = T.Lock()
statsLock = T.Lock()
stats = {"downPost": 0, "downTotal": 0, "failPost": 0, "postHad": 0}

runningFile = "/tmp/instaloot_running"

dest = os.path.join(os.environ["HOME"], "Pictures/instagram")

cacheFile = "/tmp/instaloot_cache"
cache = set()
cacheRemove = set()

setdir = ""
setdirFile = "/tmp/instaloot_setdir"

# def loadCache():
#    global cache
#    if not os.path.isfile(cacheFile):
#       return
#    with open(cacheFile, "rb") as f:
#       lockf(f, LOCK_SH)
#       cache = P.load(f)

def safeWriteOpen(filepath, fun, initf, binary=False):
   try:
      with open(filepath, "xb+" if binary else "x+") as f:
         lockf(f, LOCK_EX)
         initf(f)
         return fun(f)
   except FileExistsError:
      with open(filepath, "rb+" if binary else "r+") as f:
         lockf(f, LOCK_EX)
         return fun(f)

def saveCache():
   def doFile(f):
      toDump = (cache | P.load(f)) - cacheRemove
      f.seek(0)
      f.truncate(0)
      P.dump(toDump, f)
   def initFile(f):
      P.dump(set(), f)
      f.seek(0)
   safeWriteOpen(cacheFile, doFile, initFile, binary=True)

def testSetCache(codes):
   def doFile(f):
      global cache
      cache = P.load(f)
      newones = [x for x in codes if x not in cache]
      if not newones:
         return newones
      else:
         cache.update(newones)
         f.seek(0)
         f.truncate(0)
         P.dump(cache, f)
         return newones
   def initFile(f):
      P.dump(set(), f)
      f.seek(0)
   return safeWriteOpen(cacheFile, doFile, initFile, binary=True)

def saveSetdir():
   def doFile(f):
      f.truncate(0)
      f.write(setdir)
   safeWriteOpen(setdirFile, doFile, lambda f: f)

def loadSetdir():
   global setdir
   if setdir:
      return
   if not os.path.isfile(setdirFile):
      return
   with open(setdirFile, "r") as f:
      lockf(f, LOCK_SH)
      setdir = f.read()

def downloadPost(post):
   templ="{username}.{date}.{id}"
   looter = PostLooter(post, get_videos=True, jobs=1, template=templ)
   try:
      # find and create target dir
      username = looter.info['owner']['username']
      if setdir:
         targetPath = os.path.join(dest, setdir)
      else:
         targetPath = os.path.join(dest, username)
      os.makedirs(targetPath, exist_ok=True)

      # generate all target filenames and check if they exist
      namegen = NameGenerator(templ)
      media = looter.info
      exists = True
      total = 1
      if "edge_sidecar_to_children" in media:
         edges = media["edge_sidecar_to_children"]["edges"]
         total = len(edges)
         for m in edges:
            mc = media.copy()
            mc["id"] = m["node"]["id"]
            mc["is_video"] = m["node"]["is_video"]
            name = namegen.file(mc)
            if not os.path.isfile(os.path.join(targetPath, name)):
               exists = False
               break
      else:
         name = namegen.file(media)
         if not os.path.isfile(os.path.join(targetPath, name)):
            exists = False

      # download
      if not exists:
         looter.download(destination=targetPath)

      # record what happened
      with statsLock:
         # cache.add(post)
         if exists:
            stats["postHad"] += 1
         else:
            stats["downPost"] += 1
            stats["downTotal"] += total
   # pylint: disable=broad-except
   except Exception as e:
      with statsLock:
         cacheRemove.add(post)
         stats["failPost"] += 1
      qute_eprint(repr(e) + " : " + post)

def _qute_print(msg, cmd):
   with writeLock:
      with open(os.environ["QUTE_FIFO"], "w") as f:
         f.write("{} \"{}\"".format(cmd, msg))

def qute_print(msg):
   _qute_print(msg, "message-info")

def qute_eprint(msg):
   _qute_print(msg, "message-error")

def qute_wprint(msg):
   _qute_print(msg, "message-warning")

def display_stats(post=None):
   display_setdir = lambda: " into {}".format(setdir) if setdir else ""
   if post:
      if stats["postHad"] > 0:
         qute_print("{} was already downloaded{}".format(post, display_setdir()))
      elif stats["downPost"] > 0:
         qute_print("{} was successfully downloaded! ({} files in total){}".format(post, stats["downTotal"], display_setdir()))
      else:
         qute_print("Error or something? post={}, setdir={}".format(post, setdir))
   else:
      qute_print("Downloaded {} new posts ({} files){}, {} failed and {} were already downloaded"
                 .format(stats["downPost"],
                         stats["downTotal"],
                         display_setdir(),
                         stats["failPost"],
                         stats["postHad"]))

def run_all():
   try:
      with open(runningFile, "x") as f:
         f.write(str(os.getpid()))
      atexit.register(lambda: os.remove(runningFile))
   except FileExistsError:
      qute_wprint("Another instance of this script is already running in all-mode")
      return

   with open(os.environ["QUTE_HTML"], "r") as fp:
      soup = BeautifulSoup(fp, "html5lib")

   links = map(lambda x: x.get("href"), soup.find_all("a"))

   def getPost(l):
      if not l:
         return None
      if not re.match(r"/p/", l):
         return None
      return re.split(r"/", l)[2]

   plinks = list(filter(None, map(getPost, links)))

   notseen = testSetCache(plinks)

   amountPlinks = len(plinks)
   amountNotseen = len(notseen)
   alreadySeen = amountPlinks - amountNotseen

   if amountNotseen == 0:
      qute_print("No new links found :( ({} were cached)".format(alreadySeen))
      return

   qute_print("found {} valid links and {} cached links, starting download...".format(amountNotseen, alreadySeen))

   milestones = [0.25, 0.5, 0.75]
   while True:
      pro = 1 - (len(notseen) / amountNotseen)
      last = None
      while milestones and pro >= milestones[0]:
         last = milestones[0]
         del milestones[0]
      if last != None:
         qute_print("reached {}%".format(math.floor(last*100)))

      if T.active_count() < 8+1 and notseen:
         thr = T.Thread(target=downloadPost, args=(notseen.pop(),))
         thr.start()
      elif T.active_count() == 1:
         break
      else:
         sleep(0.5)

   if cacheRemove:
      saveCache()
   display_stats()

def run_current():
   url = os.environ["QUTE_URL"]
   mat = re.match(r"^(https://)?(www\.)?instagram\.com/p/(.+?)(/|$)", url)
   if not mat:
      qute_print("{} is an invalid link :(".format(url))
      return

   post = mat.group(3)
   if not testSetCache([post]):
      qute_print("{} was in the cache".format(post))
      return
   else:
      # qute_print("Downloading {}...".format(post))
      downloadPost(post)
      if cacheRemove:
         saveCache()
      display_stats(post)


def main():
   global setdir
   display_usage = False

   if not "QUTE_HTML" in os.environ:
      print("is this really running in qutebrowser?")
      exit(1)

   args = {}
   argv = sys.argv[1:].copy()
   while argv:
      a = argv.pop(0)
      if a == "--current":
         args['current'] = True
      elif a == "--all":
         args['all'] = True
      elif a == "--setdir":
         setdir = argv.pop(0)
         saveSetdir()
         args["setdir"] = True
      elif a == "--cleardir":
         setdir = ""
         saveSetdir()
         args["setdir"] = True
      else:
         display_usage = True
         break

   if "setdir" not in args:
      loadSetdir()

   if "current" in args:
      run_current()
   elif "all" in args:
      run_all()
   elif "setdir" in args:
      if setdir:
         isdir = os.path.isdir(os.path.join(dest, setdir))
         qute_print("Updated setdir to{} \\\"{}\\\"".format(" existing" if isdir else "", setdir))
      else:
         qute_print("Cleared setdir")
   else:
      display_usage = True

   if display_usage:
      qute_print("usage: instaloot --setdir dir | --cleardir | --current | --all")
      exit(1)

if __name__ == "__main__":
   main()
