#!/bin/python

import subprocess as P
import os
import re
import argparse
import random
import sys
from fcntl import flock, LOCK_EX
from contextlib import contextmanager

class InvalidUrlException(Exception):
   pass

HENTAIDIR = "/media/NAS/Anime/Manga/nhentai"
TOREAD = "{}/Dropbox/org/toread.org".format(os.environ["HOME"])

FIFO = ""
QUTE_URL = ""

# extremover = re.compile(r"^(.+)\.(jpg|png)$")
idfinder = re.compile(r"^\[([0-9]+?)\].*$")                       # find id from filenames
toreadfinder = re.compile(r"^https?://nhentai\.net/g/([0-9]+)/$") # find id from urls

def send_to_qute(x):
   with open(FIFO, "w") as p:
      flock(p, LOCK_EX)
      p.write("{}\n".format(x))

def message(msg):
   send_to_qute("message-info '{}'".format(msg.translate("".maketrans("", "", "\"'"))))

def downloaded_files():
   with os.scandir(HENTAIDIR) as it:
      for f in it:
         yield f

@contextmanager
def with_toread(aslist=False):
   with open(TOREAD, "r+") as f:
      flock(f, LOCK_EX)
      ids = [get_first_group(x.rstrip("\n"), toreadfinder) for x in f]
      org = ids.copy()
      if not aslist:
         ids = set(ids)

      yield ids

      if not aslist:
         order_keys = {e: i for i,e in enumerate(org)}
         ids = sorted(ids, key=lambda x: order_keys.get(x, len(org)))

      fmt = "https://nhentai.net/g/{}/\n"
      if ids != org:
         f.seek(0, 0) #goto beginning
         f.truncate()
         for i in ids:
            f.write(fmt.format(i))

def get_first_group(name, reg):
   return reg.sub(r"\1", name)

def get_downloaded_ids():
   return {get_first_group(x.name, idfinder) for x in downloaded_files()}

def get_qute_id():
   if not toreadfinder.fullmatch(QUTE_URL):
      message("invalid url: {}".format(QUTE_URL))
      raise InvalidUrlException("invalid QUTE_URL: {}".format(QUTE_URL))

   return get_first_group(QUTE_URL, toreadfinder)

def toread_random():
   with with_toread() as ids:
      if not ids:
         message("file empty")
         return

      r = random.sample(ids, 1)[0]
      ids.remove(r)
      send_to_qute("open https://nhentai.net/g/{}/".format(r))

def check_existance():
   db_ids = get_downloaded_ids()
   try:
      hid = get_qute_id()
   except InvalidUrlException:
      return
   with with_toread() as ids:
      res = ""

      if hid in db_ids:
         res = "is downloaded"

      if hid in ids:
         if res:
            res += " and "
         res += "is planned to be read"

      if res:
         message(res)
      else:
         message("never seen before")

def add_toread():
   try:
      hid = get_qute_id()
   except InvalidUrlException:
      return

   with with_toread() as ids:
      if hid in ids:
         message("{} is already added".format(hid))
      elif hid in get_downloaded_ids():
         message("{} is already downloaded, no need".format(hid))
      else:
         ids.add(hid)
         message("added {}".format(hid))

def remove_toread():
   try:
      hid = get_qute_id()
   except InvalidUrlException:
      return

   with with_toread() as ids:
      if hid in ids:
         message("removing {} from toread".format(hid))
         ids.remove(hid)
      else:
         message("nothing to remove")

def undo():
   with with_toread(aslist=True) as ids:
      if not ids:
         message("file empty")
         return
      hid = ids.pop()
      message("removed {}".format(hid))

def download():
   try:
      hid = get_qute_id()
   except InvalidUrlException:
      return

   if hid in get_downloaded_ids():
      message("{} is already downloaded".format(hid))
      return

   message("starting download of {}".format(hid))
   fp = P.run(["nhentai",
               "--id={}".format(hid),
               "--cbz",
               "--no-html",
               "--rm-origin-dir",
               "--output={}".format(HENTAIDIR)
            ],
            stdout=P.PIPE,
            stderr=P.PIPE,
            text=True,
            check=False)

   if fp.stderr:
      for l in fp.stderr.split("\n"):
         message(l)
      raise Exception("nhentai downloader wrote something to stderr")

   warningerror = re.compile(r".*\[(WARNING|ERROR)\]")
   ignoreerrors = ["does not exist, creating.", "`nhentai --cookie` to set your cookie"]
   for l in fp.stdout.split("\n"):
      if warningerror.match(l) and not any(l.endswith(x) for x in ignoreerrors):
         message(l)

   fp.check_returncode()

   with with_toread() as ids:
      if hid in ids:
         ids.remove(hid)

   message("done with {}".format(hid))

def main():
   global FIFO, QUTE_URL
   if "QUTE_FIFO" not in os.environ or "QUTE_URL" not in os.environ:
      print("this must be run from withing qutebrowser", file=sys.stderr)
      exit(1)

   FIFO = os.environ["QUTE_FIFO"]
   QUTE_URL = os.environ["QUTE_URL"]

   parser = argparse.ArgumentParser(description="some things to organize nhentai chapters")

   parser.add_argument("url", nargs="?", default=QUTE_URL)
   parser.add_argument("--add", action="store_true", help="add to toread")
   parser.add_argument("--exists", action="store_true", help="check if we have seen this thing before")
   parser.add_argument("--random", action="store_true", help="open a new chapter from toread")
   parser.add_argument("--download", action="store_true", help="download current chapter")
   parser.add_argument("--undo", action="store_true", help="remove latest addition to toread")
   parser.add_argument("--remove", action="store_true", help="remove current chapter from toread")

   args = parser.parse_args()
   QUTE_URL = args.url

   if args.add:
      add_toread()
   elif args.exists:
      check_existance()
   elif args.random:
      toread_random()
   elif args.download:
      download()
   elif args.undo:
      undo()
   elif args.remove:
      remove_toread()

if __name__ == "__main__":
   main()
